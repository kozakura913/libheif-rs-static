/* automatically generated by rust-bindgen 0.70.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const LIBHEIF_NUMERIC_VERSION: u32 = 18023168;
pub const LIBHEIF_VERSION: &[u8; 7] = b"1.19.3\0";
pub const LIBHEIF_PLUGIN_DIRECTORY : & [u8 ; 110] = b"/home/eratou/projects/libheif-rs-static/target/debug/build/libheif-rs-static-695f85dfab369fef/out/lib/libheif\0" ;
pub const LIBHEIF_AUX_IMAGE_FILTER_OMIT_ALPHA: u32 = 2;
pub const LIBHEIF_AUX_IMAGE_FILTER_OMIT_DEPTH: u32 = 4;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn heif_get_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heif_get_version_number() -> u32;
}
extern "C" {
    pub fn heif_get_version_number_major() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_get_version_number_minor() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_get_version_number_maintenance() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_image_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_image {
    _unused: [u8; 0],
}
pub const heif_error_code_heif_error_Ok: heif_error_code = 0;
pub const heif_error_code_heif_error_Input_does_not_exist: heif_error_code = 1;
pub const heif_error_code_heif_error_Invalid_input: heif_error_code = 2;
pub const heif_error_code_heif_error_Unsupported_filetype: heif_error_code = 3;
pub const heif_error_code_heif_error_Unsupported_feature: heif_error_code = 4;
pub const heif_error_code_heif_error_Usage_error: heif_error_code = 5;
pub const heif_error_code_heif_error_Memory_allocation_error: heif_error_code = 6;
pub const heif_error_code_heif_error_Decoder_plugin_error: heif_error_code = 7;
pub const heif_error_code_heif_error_Encoder_plugin_error: heif_error_code = 8;
pub const heif_error_code_heif_error_Encoding_error: heif_error_code = 9;
pub const heif_error_code_heif_error_Color_profile_does_not_exist: heif_error_code = 10;
pub const heif_error_code_heif_error_Plugin_loading_error: heif_error_code = 11;
pub const heif_error_code_heif_error_Canceled: heif_error_code = 12;
pub type heif_error_code = ::std::os::raw::c_uint;
pub const heif_suberror_code_heif_suberror_Unspecified: heif_suberror_code = 0;
pub const heif_suberror_code_heif_suberror_End_of_data: heif_suberror_code = 100;
pub const heif_suberror_code_heif_suberror_Invalid_box_size: heif_suberror_code = 101;
pub const heif_suberror_code_heif_suberror_No_ftyp_box: heif_suberror_code = 102;
pub const heif_suberror_code_heif_suberror_No_idat_box: heif_suberror_code = 103;
pub const heif_suberror_code_heif_suberror_No_meta_box: heif_suberror_code = 104;
pub const heif_suberror_code_heif_suberror_No_hdlr_box: heif_suberror_code = 105;
pub const heif_suberror_code_heif_suberror_No_hvcC_box: heif_suberror_code = 106;
pub const heif_suberror_code_heif_suberror_No_pitm_box: heif_suberror_code = 107;
pub const heif_suberror_code_heif_suberror_No_ipco_box: heif_suberror_code = 108;
pub const heif_suberror_code_heif_suberror_No_ipma_box: heif_suberror_code = 109;
pub const heif_suberror_code_heif_suberror_No_iloc_box: heif_suberror_code = 110;
pub const heif_suberror_code_heif_suberror_No_iinf_box: heif_suberror_code = 111;
pub const heif_suberror_code_heif_suberror_No_iprp_box: heif_suberror_code = 112;
pub const heif_suberror_code_heif_suberror_No_iref_box: heif_suberror_code = 113;
pub const heif_suberror_code_heif_suberror_No_pict_handler: heif_suberror_code = 114;
pub const heif_suberror_code_heif_suberror_Ipma_box_references_nonexisting_property:
    heif_suberror_code = 115;
pub const heif_suberror_code_heif_suberror_No_properties_assigned_to_item: heif_suberror_code = 116;
pub const heif_suberror_code_heif_suberror_No_item_data: heif_suberror_code = 117;
pub const heif_suberror_code_heif_suberror_Invalid_grid_data: heif_suberror_code = 118;
pub const heif_suberror_code_heif_suberror_Missing_grid_images: heif_suberror_code = 119;
pub const heif_suberror_code_heif_suberror_Invalid_clean_aperture: heif_suberror_code = 120;
pub const heif_suberror_code_heif_suberror_Invalid_overlay_data: heif_suberror_code = 121;
pub const heif_suberror_code_heif_suberror_Overlay_image_outside_of_canvas: heif_suberror_code =
    122;
pub const heif_suberror_code_heif_suberror_Auxiliary_image_type_unspecified: heif_suberror_code =
    123;
pub const heif_suberror_code_heif_suberror_No_or_invalid_primary_item: heif_suberror_code = 124;
pub const heif_suberror_code_heif_suberror_No_infe_box: heif_suberror_code = 125;
pub const heif_suberror_code_heif_suberror_Unknown_color_profile_type: heif_suberror_code = 126;
pub const heif_suberror_code_heif_suberror_Wrong_tile_image_chroma_format: heif_suberror_code = 127;
pub const heif_suberror_code_heif_suberror_Invalid_fractional_number: heif_suberror_code = 128;
pub const heif_suberror_code_heif_suberror_Invalid_image_size: heif_suberror_code = 129;
pub const heif_suberror_code_heif_suberror_Invalid_pixi_box: heif_suberror_code = 130;
pub const heif_suberror_code_heif_suberror_No_av1C_box: heif_suberror_code = 131;
pub const heif_suberror_code_heif_suberror_Wrong_tile_image_pixel_depth: heif_suberror_code = 132;
pub const heif_suberror_code_heif_suberror_Unknown_NCLX_color_primaries: heif_suberror_code = 133;
pub const heif_suberror_code_heif_suberror_Unknown_NCLX_transfer_characteristics:
    heif_suberror_code = 134;
pub const heif_suberror_code_heif_suberror_Unknown_NCLX_matrix_coefficients: heif_suberror_code =
    135;
pub const heif_suberror_code_heif_suberror_Invalid_region_data: heif_suberror_code = 136;
pub const heif_suberror_code_heif_suberror_No_ispe_property: heif_suberror_code = 137;
pub const heif_suberror_code_heif_suberror_Camera_intrinsic_matrix_undefined: heif_suberror_code =
    138;
pub const heif_suberror_code_heif_suberror_Camera_extrinsic_matrix_undefined: heif_suberror_code =
    139;
pub const heif_suberror_code_heif_suberror_Invalid_J2K_codestream: heif_suberror_code = 140;
pub const heif_suberror_code_heif_suberror_No_vvcC_box: heif_suberror_code = 141;
pub const heif_suberror_code_heif_suberror_No_icbr_box: heif_suberror_code = 142;
pub const heif_suberror_code_heif_suberror_No_avcC_box: heif_suberror_code = 143;
pub const heif_suberror_code_heif_suberror_Invalid_mini_box: heif_suberror_code = 149;
pub const heif_suberror_code_heif_suberror_Decompression_invalid_data: heif_suberror_code = 150;
pub const heif_suberror_code_heif_suberror_Security_limit_exceeded: heif_suberror_code = 1000;
pub const heif_suberror_code_heif_suberror_Compression_initialisation_error: heif_suberror_code =
    1001;
pub const heif_suberror_code_heif_suberror_Nonexisting_item_referenced: heif_suberror_code = 2000;
pub const heif_suberror_code_heif_suberror_Null_pointer_argument: heif_suberror_code = 2001;
pub const heif_suberror_code_heif_suberror_Nonexisting_image_channel_referenced:
    heif_suberror_code = 2002;
pub const heif_suberror_code_heif_suberror_Unsupported_plugin_version: heif_suberror_code = 2003;
pub const heif_suberror_code_heif_suberror_Unsupported_writer_version: heif_suberror_code = 2004;
pub const heif_suberror_code_heif_suberror_Unsupported_parameter: heif_suberror_code = 2005;
pub const heif_suberror_code_heif_suberror_Invalid_parameter_value: heif_suberror_code = 2006;
pub const heif_suberror_code_heif_suberror_Invalid_property: heif_suberror_code = 2007;
pub const heif_suberror_code_heif_suberror_Item_reference_cycle: heif_suberror_code = 2008;
pub const heif_suberror_code_heif_suberror_Unsupported_codec: heif_suberror_code = 3000;
pub const heif_suberror_code_heif_suberror_Unsupported_image_type: heif_suberror_code = 3001;
pub const heif_suberror_code_heif_suberror_Unsupported_data_version: heif_suberror_code = 3002;
pub const heif_suberror_code_heif_suberror_Unsupported_color_conversion: heif_suberror_code = 3003;
pub const heif_suberror_code_heif_suberror_Unsupported_item_construction_method:
    heif_suberror_code = 3004;
pub const heif_suberror_code_heif_suberror_Unsupported_header_compression_method:
    heif_suberror_code = 3005;
pub const heif_suberror_code_heif_suberror_Unsupported_generic_compression_method:
    heif_suberror_code = 3006;
pub const heif_suberror_code_heif_suberror_Unsupported_essential_property: heif_suberror_code =
    3007;
pub const heif_suberror_code_heif_suberror_Unsupported_bit_depth: heif_suberror_code = 4000;
pub const heif_suberror_code_heif_suberror_Cannot_write_output_data: heif_suberror_code = 5000;
pub const heif_suberror_code_heif_suberror_Encoder_initialization: heif_suberror_code = 5001;
pub const heif_suberror_code_heif_suberror_Encoder_encoding: heif_suberror_code = 5002;
pub const heif_suberror_code_heif_suberror_Encoder_cleanup: heif_suberror_code = 5003;
pub const heif_suberror_code_heif_suberror_Too_many_regions: heif_suberror_code = 5004;
pub const heif_suberror_code_heif_suberror_Plugin_loading_error: heif_suberror_code = 6000;
pub const heif_suberror_code_heif_suberror_Plugin_is_not_loaded: heif_suberror_code = 6001;
pub const heif_suberror_code_heif_suberror_Cannot_read_plugin_directory: heif_suberror_code = 6002;
pub const heif_suberror_code_heif_suberror_No_matching_decoder_installed: heif_suberror_code = 6003;
pub type heif_suberror_code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_error {
    pub code: heif_error_code,
    pub subcode: heif_suberror_code,
    pub message: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_error"][::std::mem::size_of::<heif_error>() - 16usize];
    ["Alignment of heif_error"][::std::mem::align_of::<heif_error>() - 8usize];
    ["Offset of field: heif_error::code"][::std::mem::offset_of!(heif_error, code) - 0usize];
    ["Offset of field: heif_error::subcode"][::std::mem::offset_of!(heif_error, subcode) - 4usize];
    ["Offset of field: heif_error::message"][::std::mem::offset_of!(heif_error, message) - 8usize];
};
extern "C" {
    pub static heif_error_success: heif_error;
}
pub type heif_item_id = u32;
pub type heif_property_id = u32;
#[doc = " Unspecified / undefined compression format.\n\n This is used to mean \"no match\" or \"any decoder\" for some parts of the\n API. It does not indicate a specific compression format."]
pub const heif_compression_format_heif_compression_undefined: heif_compression_format = 0;
#[doc = " HEVC compression, used for HEIC images.\n\n This is equivalent to H.265."]
pub const heif_compression_format_heif_compression_HEVC: heif_compression_format = 1;
#[doc = " AVC compression. (Currently unused in libheif.)\n\n The compression is defined in ISO/IEC 14496-10. This is equivalent to H.264.\n\n The encapsulation is defined in ISO/IEC 23008-12:2022 Annex E."]
pub const heif_compression_format_heif_compression_AVC: heif_compression_format = 2;
#[doc = " JPEG compression.\n\n The compression format is defined in ISO/IEC 10918-1. The encapsulation\n of JPEG is specified in ISO/IEC 23008-12:2022 Annex H."]
pub const heif_compression_format_heif_compression_JPEG: heif_compression_format = 3;
#[doc = " AV1 compression, used for AVIF images.\n\n The compression format is provided at https://aomediacodec.github.io/av1-spec/\n\n The encapsulation is defined in https://aomediacodec.github.io/av1-avif/"]
pub const heif_compression_format_heif_compression_AV1: heif_compression_format = 4;
#[doc = " VVC compression.\n\n The compression format is defined in ISO/IEC 23090-3. This is equivalent to H.266.\n\n The encapsulation is defined in ISO/IEC 23008-12:2022 Annex L."]
pub const heif_compression_format_heif_compression_VVC: heif_compression_format = 5;
#[doc = " EVC compression. (Currently unused in libheif.)\n\n The compression format is defined in ISO/IEC 23094-1.\n\n The encapsulation is defined in ISO/IEC 23008-12:2022 Annex M."]
pub const heif_compression_format_heif_compression_EVC: heif_compression_format = 6;
#[doc = " JPEG 2000 compression.\n\n The encapsulation of JPEG 2000 is specified in ISO/IEC 15444-16:2021.\n The core encoding is defined in ISO/IEC 15444-1, or ITU-T T.800."]
pub const heif_compression_format_heif_compression_JPEG2000: heif_compression_format = 7;
#[doc = " Uncompressed encoding.\n\n This is defined in ISO/IEC 23001-17:2024."]
pub const heif_compression_format_heif_compression_uncompressed: heif_compression_format = 8;
#[doc = " Mask image encoding.\n\n See ISO/IEC 23008-12:2022 Section 6.10.2"]
pub const heif_compression_format_heif_compression_mask: heif_compression_format = 9;
#[doc = " High Throughput JPEG 2000 (HT-J2K) compression.\n\n The encapsulation of HT-J2K is specified in ISO/IEC 15444-16:2021.\n The core encoding is defined in ISO/IEC 15444-15, or ITU-T T.814."]
pub const heif_compression_format_heif_compression_HTJ2K: heif_compression_format = 10;
#[doc = " libheif known compression formats."]
pub type heif_compression_format = ::std::os::raw::c_uint;
pub const heif_chroma_heif_chroma_undefined: heif_chroma = 99;
pub const heif_chroma_heif_chroma_monochrome: heif_chroma = 0;
pub const heif_chroma_heif_chroma_420: heif_chroma = 1;
pub const heif_chroma_heif_chroma_422: heif_chroma = 2;
pub const heif_chroma_heif_chroma_444: heif_chroma = 3;
pub const heif_chroma_heif_chroma_interleaved_RGB: heif_chroma = 10;
pub const heif_chroma_heif_chroma_interleaved_RGBA: heif_chroma = 11;
pub const heif_chroma_heif_chroma_interleaved_RRGGBB_BE: heif_chroma = 12;
pub const heif_chroma_heif_chroma_interleaved_RRGGBBAA_BE: heif_chroma = 13;
pub const heif_chroma_heif_chroma_interleaved_RRGGBB_LE: heif_chroma = 14;
pub const heif_chroma_heif_chroma_interleaved_RRGGBBAA_LE: heif_chroma = 15;
pub type heif_chroma = ::std::os::raw::c_uint;
pub const heif_colorspace_heif_colorspace_undefined: heif_colorspace = 99;
pub const heif_colorspace_heif_colorspace_YCbCr: heif_colorspace = 0;
pub const heif_colorspace_heif_colorspace_RGB: heif_colorspace = 1;
pub const heif_colorspace_heif_colorspace_monochrome: heif_colorspace = 2;
pub const heif_colorspace_heif_colorspace_nonvisual: heif_colorspace = 3;
pub type heif_colorspace = ::std::os::raw::c_uint;
pub const heif_channel_heif_channel_Y: heif_channel = 0;
pub const heif_channel_heif_channel_Cb: heif_channel = 1;
pub const heif_channel_heif_channel_Cr: heif_channel = 2;
pub const heif_channel_heif_channel_R: heif_channel = 3;
pub const heif_channel_heif_channel_G: heif_channel = 4;
pub const heif_channel_heif_channel_B: heif_channel = 5;
pub const heif_channel_heif_channel_Alpha: heif_channel = 6;
pub const heif_channel_heif_channel_interleaved: heif_channel = 10;
pub const heif_channel_heif_channel_filter_array: heif_channel = 11;
pub const heif_channel_heif_channel_depth: heif_channel = 12;
pub const heif_channel_heif_channel_disparity: heif_channel = 13;
pub type heif_channel = ::std::os::raw::c_uint;
pub const heif_metadata_compression_heif_metadata_compression_off: heif_metadata_compression = 0;
pub const heif_metadata_compression_heif_metadata_compression_auto: heif_metadata_compression = 1;
pub const heif_metadata_compression_heif_metadata_compression_unknown: heif_metadata_compression =
    2;
pub const heif_metadata_compression_heif_metadata_compression_deflate: heif_metadata_compression =
    3;
pub const heif_metadata_compression_heif_metadata_compression_zlib: heif_metadata_compression = 4;
pub const heif_metadata_compression_heif_metadata_compression_brotli: heif_metadata_compression = 5;
pub type heif_metadata_compression = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_init_params {
    pub version: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_init_params"][::std::mem::size_of::<heif_init_params>() - 4usize];
    ["Alignment of heif_init_params"][::std::mem::align_of::<heif_init_params>() - 4usize];
    ["Offset of field: heif_init_params::version"]
        [::std::mem::offset_of!(heif_init_params, version) - 0usize];
};
extern "C" {
    #[doc = " Initialise library.\n\n You should call heif_init() when you start using libheif and heif_deinit() when you are finished.\n These calls are reference counted. Each call to heif_init() should be matched by one call to heif_deinit().\n\n For backwards compatibility, it is not really necessary to call heif_init(), but some library memory objects\n will never be freed if you do not call heif_init()/heif_deinit().\n\n heif_init() will load the external modules installed in the default plugin path. Thus, you need it when you\n want to load external plugins from the default path.\n Codec plugins that are compiled into the library directly (selected by the compile-time parameters of libheif)\n will be available even without heif_init().\n\n Make sure that you do not have one part of your program use heif_init()/heif_deinit() and another part that does\n not use it as the latter may try to use an uninitialized library. If in doubt, enclose everything with init/deinit.\n\n You may pass nullptr to get default parameters. Currently, no parameters are supported."]
    pub fn heif_init(arg1: *mut heif_init_params) -> heif_error;
}
extern "C" {
    #[doc = " Deinitialise and clean up library.\n\n You should call heif_init() when you start using libheif and heif_deinit() when you are finished.\n These calls are reference counted. Each call to heif_init() should be matched by one call to heif_deinit().\n\n Note: heif_deinit() must not be called after exit(), for example in a global C++ object's destructor.\n If you do, global variables in libheif might have already been released when heif_deinit() is running,\n leading to a crash.\n\n \\sa heif_init()"]
    pub fn heif_deinit();
}
pub const heif_plugin_type_heif_plugin_type_encoder: heif_plugin_type = 0;
pub const heif_plugin_type_heif_plugin_type_decoder: heif_plugin_type = 1;
pub type heif_plugin_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_plugin_info {
    pub version: ::std::os::raw::c_int,
    pub type_: heif_plugin_type,
    pub plugin: *const ::std::os::raw::c_void,
    pub internal_handle: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_plugin_info"][::std::mem::size_of::<heif_plugin_info>() - 24usize];
    ["Alignment of heif_plugin_info"][::std::mem::align_of::<heif_plugin_info>() - 8usize];
    ["Offset of field: heif_plugin_info::version"]
        [::std::mem::offset_of!(heif_plugin_info, version) - 0usize];
    ["Offset of field: heif_plugin_info::type_"]
        [::std::mem::offset_of!(heif_plugin_info, type_) - 4usize];
    ["Offset of field: heif_plugin_info::plugin"]
        [::std::mem::offset_of!(heif_plugin_info, plugin) - 8usize];
    ["Offset of field: heif_plugin_info::internal_handle"]
        [::std::mem::offset_of!(heif_plugin_info, internal_handle) - 16usize];
};
extern "C" {
    pub fn heif_load_plugin(
        filename: *const ::std::os::raw::c_char,
        out_plugin: *mut *const heif_plugin_info,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_load_plugins(
        directory: *const ::std::os::raw::c_char,
        out_plugins: *mut *const heif_plugin_info,
        out_nPluginsLoaded: *mut ::std::os::raw::c_int,
        output_array_size: ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_unload_plugin(plugin: *const heif_plugin_info) -> heif_error;
}
extern "C" {
    pub fn heif_get_plugin_directories() -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heif_free_plugin_directories(arg1: *const *const ::std::os::raw::c_char);
}
pub const heif_filetype_result_heif_filetype_no: heif_filetype_result = 0;
pub const heif_filetype_result_heif_filetype_yes_supported: heif_filetype_result = 1;
pub const heif_filetype_result_heif_filetype_yes_unsupported: heif_filetype_result = 2;
pub const heif_filetype_result_heif_filetype_maybe: heif_filetype_result = 3;
pub type heif_filetype_result = ::std::os::raw::c_uint;
extern "C" {
    pub fn heif_check_filetype(data: *const u8, len: ::std::os::raw::c_int)
        -> heif_filetype_result;
}
extern "C" {
    #[doc = " Check the filetype box content for a supported file type.\n\n <p>The data is assumed to start from the start of the `ftyp` box.\n\n <p>This function checks the compatible brands.\n\n @returns heif_error_ok if a supported brand is found, or other error if not."]
    pub fn heif_has_compatible_filetype(data: *const u8, len: ::std::os::raw::c_int) -> heif_error;
}
extern "C" {
    pub fn heif_check_jpeg_filetype(
        data: *const u8,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const heif_brand_heif_unknown_brand: heif_brand = 0;
pub const heif_brand_heif_heic: heif_brand = 1;
pub const heif_brand_heif_heix: heif_brand = 2;
pub const heif_brand_heif_hevc: heif_brand = 3;
pub const heif_brand_heif_hevx: heif_brand = 4;
pub const heif_brand_heif_heim: heif_brand = 5;
pub const heif_brand_heif_heis: heif_brand = 6;
pub const heif_brand_heif_hevm: heif_brand = 7;
pub const heif_brand_heif_hevs: heif_brand = 8;
pub const heif_brand_heif_mif1: heif_brand = 9;
pub const heif_brand_heif_msf1: heif_brand = 10;
pub const heif_brand_heif_avif: heif_brand = 11;
pub const heif_brand_heif_avis: heif_brand = 12;
pub const heif_brand_heif_vvic: heif_brand = 13;
pub const heif_brand_heif_vvis: heif_brand = 14;
pub const heif_brand_heif_evbi: heif_brand = 15;
pub const heif_brand_heif_evbs: heif_brand = 16;
pub const heif_brand_heif_j2ki: heif_brand = 17;
pub const heif_brand_heif_j2is: heif_brand = 18;
pub type heif_brand = ::std::os::raw::c_uint;
extern "C" {
    pub fn heif_main_brand(data: *const u8, len: ::std::os::raw::c_int) -> heif_brand;
}
pub type heif_brand2 = u32;
extern "C" {
    pub fn heif_read_main_brand(data: *const u8, len: ::std::os::raw::c_int) -> heif_brand2;
}
extern "C" {
    pub fn heif_read_minor_version_brand(
        data: *const u8,
        len: ::std::os::raw::c_int,
    ) -> heif_brand2;
}
extern "C" {
    pub fn heif_fourcc_to_brand(brand_fourcc: *const ::std::os::raw::c_char) -> heif_brand2;
}
extern "C" {
    pub fn heif_brand_to_fourcc(brand: heif_brand2, out_fourcc: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn heif_has_compatible_brand(
        data: *const u8,
        len: ::std::os::raw::c_int,
        brand_fourcc: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_list_compatible_brands(
        data: *const u8,
        len: ::std::os::raw::c_int,
        out_brands: *mut *mut heif_brand2,
        out_size: *mut ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_free_list_of_compatible_brands(brands_list: *mut heif_brand2);
}
extern "C" {
    pub fn heif_get_file_mime_type(
        data: *const u8,
        len: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heif_context_alloc() -> *mut heif_context;
}
extern "C" {
    pub fn heif_context_free(arg1: *mut heif_context);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_reading_options {
    _unused: [u8; 0],
}
pub const heif_reader_grow_status_heif_reader_grow_status_size_reached: heif_reader_grow_status = 0;
pub const heif_reader_grow_status_heif_reader_grow_status_timeout: heif_reader_grow_status = 1;
pub const heif_reader_grow_status_heif_reader_grow_status_size_beyond_eof: heif_reader_grow_status =
    2;
pub const heif_reader_grow_status_heif_reader_grow_status_error: heif_reader_grow_status = 3;
pub type heif_reader_grow_status = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_reader_range_request_result {
    pub status: heif_reader_grow_status,
    pub range_end: u64,
    pub reader_error_code: ::std::os::raw::c_int,
    pub reader_error_msg: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_reader_range_request_result"]
        [::std::mem::size_of::<heif_reader_range_request_result>() - 32usize];
    ["Alignment of heif_reader_range_request_result"]
        [::std::mem::align_of::<heif_reader_range_request_result>() - 8usize];
    ["Offset of field: heif_reader_range_request_result::status"]
        [::std::mem::offset_of!(heif_reader_range_request_result, status) - 0usize];
    ["Offset of field: heif_reader_range_request_result::range_end"]
        [::std::mem::offset_of!(heif_reader_range_request_result, range_end) - 8usize];
    ["Offset of field: heif_reader_range_request_result::reader_error_code"]
        [::std::mem::offset_of!(heif_reader_range_request_result, reader_error_code) - 16usize];
    ["Offset of field: heif_reader_range_request_result::reader_error_msg"]
        [::std::mem::offset_of!(heif_reader_range_request_result, reader_error_msg) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_reader {
    pub reader_api_version: ::std::os::raw::c_int,
    pub get_position:
        ::std::option::Option<unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void) -> i64>,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            size: usize,
            userdata: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            position: i64,
            userdata: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub wait_for_file_size: ::std::option::Option<
        unsafe extern "C" fn(
            target_size: i64,
            userdata: *mut ::std::os::raw::c_void,
        ) -> heif_reader_grow_status,
    >,
    pub request_range: ::std::option::Option<
        unsafe extern "C" fn(
            start_pos: u64,
            end_pos: u64,
            userdata: *mut ::std::os::raw::c_void,
        ) -> heif_reader_range_request_result,
    >,
    pub preload_range_hint: ::std::option::Option<
        unsafe extern "C" fn(start_pos: u64, end_pos: u64, userdata: *mut ::std::os::raw::c_void),
    >,
    pub release_file_range: ::std::option::Option<
        unsafe extern "C" fn(start_pos: u64, end_pos: u64, userdata: *mut ::std::os::raw::c_void),
    >,
    pub release_error_msg:
        ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_reader"][::std::mem::size_of::<heif_reader>() - 72usize];
    ["Alignment of heif_reader"][::std::mem::align_of::<heif_reader>() - 8usize];
    ["Offset of field: heif_reader::reader_api_version"]
        [::std::mem::offset_of!(heif_reader, reader_api_version) - 0usize];
    ["Offset of field: heif_reader::get_position"]
        [::std::mem::offset_of!(heif_reader, get_position) - 8usize];
    ["Offset of field: heif_reader::read"][::std::mem::offset_of!(heif_reader, read) - 16usize];
    ["Offset of field: heif_reader::seek"][::std::mem::offset_of!(heif_reader, seek) - 24usize];
    ["Offset of field: heif_reader::wait_for_file_size"]
        [::std::mem::offset_of!(heif_reader, wait_for_file_size) - 32usize];
    ["Offset of field: heif_reader::request_range"]
        [::std::mem::offset_of!(heif_reader, request_range) - 40usize];
    ["Offset of field: heif_reader::preload_range_hint"]
        [::std::mem::offset_of!(heif_reader, preload_range_hint) - 48usize];
    ["Offset of field: heif_reader::release_file_range"]
        [::std::mem::offset_of!(heif_reader, release_file_range) - 56usize];
    ["Offset of field: heif_reader::release_error_msg"]
        [::std::mem::offset_of!(heif_reader, release_error_msg) - 64usize];
};
extern "C" {
    pub fn heif_context_read_from_file(
        arg1: *mut heif_context,
        filename: *const ::std::os::raw::c_char,
        arg2: *const heif_reading_options,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_read_from_memory(
        arg1: *mut heif_context,
        mem: *const ::std::os::raw::c_void,
        size: usize,
        arg2: *const heif_reading_options,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_read_from_memory_without_copy(
        arg1: *mut heif_context,
        mem: *const ::std::os::raw::c_void,
        size: usize,
        arg2: *const heif_reading_options,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_read_from_reader(
        arg1: *mut heif_context,
        reader: *const heif_reader,
        userdata: *mut ::std::os::raw::c_void,
        arg2: *const heif_reading_options,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_get_number_of_top_level_images(
        ctx: *mut heif_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_context_is_top_level_image_ID(
        ctx: *mut heif_context,
        id: heif_item_id,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_context_get_list_of_top_level_image_IDs(
        ctx: *mut heif_context,
        ID_array: *mut heif_item_id,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_context_get_primary_image_ID(
        ctx: *mut heif_context,
        id: *mut heif_item_id,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_get_primary_image_handle(
        ctx: *mut heif_context,
        arg1: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_get_image_handle(
        ctx: *mut heif_context,
        id: heif_item_id,
        arg1: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_debug_dump_boxes_to_file(ctx: *mut heif_context, fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn heif_context_set_maximum_image_size_limit(
        ctx: *mut heif_context,
        maximum_width: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn heif_context_set_max_decoding_threads(
        ctx: *mut heif_context,
        max_threads: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_security_limits {
    pub version: u8,
    pub max_image_size_pixels: u64,
    pub max_number_of_tiles: u64,
    pub max_bayer_pattern_pixels: u32,
    pub max_items: u32,
    pub max_color_profile_size: u32,
    pub max_memory_block_size: u64,
    pub max_components: u32,
    pub max_iloc_extents_per_item: u32,
    pub max_size_entity_group: u32,
    pub max_children_per_box: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_security_limits"][::std::mem::size_of::<heif_security_limits>() - 64usize];
    ["Alignment of heif_security_limits"][::std::mem::align_of::<heif_security_limits>() - 8usize];
    ["Offset of field: heif_security_limits::version"]
        [::std::mem::offset_of!(heif_security_limits, version) - 0usize];
    ["Offset of field: heif_security_limits::max_image_size_pixels"]
        [::std::mem::offset_of!(heif_security_limits, max_image_size_pixels) - 8usize];
    ["Offset of field: heif_security_limits::max_number_of_tiles"]
        [::std::mem::offset_of!(heif_security_limits, max_number_of_tiles) - 16usize];
    ["Offset of field: heif_security_limits::max_bayer_pattern_pixels"]
        [::std::mem::offset_of!(heif_security_limits, max_bayer_pattern_pixels) - 24usize];
    ["Offset of field: heif_security_limits::max_items"]
        [::std::mem::offset_of!(heif_security_limits, max_items) - 28usize];
    ["Offset of field: heif_security_limits::max_color_profile_size"]
        [::std::mem::offset_of!(heif_security_limits, max_color_profile_size) - 32usize];
    ["Offset of field: heif_security_limits::max_memory_block_size"]
        [::std::mem::offset_of!(heif_security_limits, max_memory_block_size) - 40usize];
    ["Offset of field: heif_security_limits::max_components"]
        [::std::mem::offset_of!(heif_security_limits, max_components) - 48usize];
    ["Offset of field: heif_security_limits::max_iloc_extents_per_item"]
        [::std::mem::offset_of!(heif_security_limits, max_iloc_extents_per_item) - 52usize];
    ["Offset of field: heif_security_limits::max_size_entity_group"]
        [::std::mem::offset_of!(heif_security_limits, max_size_entity_group) - 56usize];
    ["Offset of field: heif_security_limits::max_children_per_box"]
        [::std::mem::offset_of!(heif_security_limits, max_children_per_box) - 60usize];
};
extern "C" {
    pub fn heif_get_global_security_limits() -> *const heif_security_limits;
}
extern "C" {
    pub fn heif_get_disabled_security_limits() -> *const heif_security_limits;
}
extern "C" {
    pub fn heif_context_get_security_limits(arg1: *const heif_context)
        -> *mut heif_security_limits;
}
extern "C" {
    pub fn heif_context_set_security_limits(
        arg1: *mut heif_context,
        arg2: *const heif_security_limits,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_handle_release(arg1: *const heif_image_handle);
}
extern "C" {
    pub fn heif_image_handle_is_primary_image(
        handle: *const heif_image_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_item_id(handle: *const heif_image_handle) -> heif_item_id;
}
extern "C" {
    pub fn heif_image_handle_get_width(handle: *const heif_image_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_height(handle: *const heif_image_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_has_alpha_channel(
        arg1: *const heif_image_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_is_premultiplied_alpha(
        arg1: *const heif_image_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_luma_bits_per_pixel(
        arg1: *const heif_image_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_chroma_bits_per_pixel(
        arg1: *const heif_image_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_preferred_decoding_colorspace(
        image_handle: *const heif_image_handle,
        out_colorspace: *mut heif_colorspace,
        out_chroma: *mut heif_chroma,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_handle_get_ispe_width(
        handle: *const heif_image_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_ispe_height(
        handle: *const heif_image_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_context(handle: *const heif_image_handle) -> *mut heif_context;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_image_tiling {
    pub version: ::std::os::raw::c_int,
    pub num_columns: u32,
    pub num_rows: u32,
    pub tile_width: u32,
    pub tile_height: u32,
    pub image_width: u32,
    pub image_height: u32,
    pub top_offset: u32,
    pub left_offset: u32,
    pub number_of_extra_dimensions: u8,
    pub extra_dimension_size: [u32; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_image_tiling"][::std::mem::size_of::<heif_image_tiling>() - 72usize];
    ["Alignment of heif_image_tiling"][::std::mem::align_of::<heif_image_tiling>() - 4usize];
    ["Offset of field: heif_image_tiling::version"]
        [::std::mem::offset_of!(heif_image_tiling, version) - 0usize];
    ["Offset of field: heif_image_tiling::num_columns"]
        [::std::mem::offset_of!(heif_image_tiling, num_columns) - 4usize];
    ["Offset of field: heif_image_tiling::num_rows"]
        [::std::mem::offset_of!(heif_image_tiling, num_rows) - 8usize];
    ["Offset of field: heif_image_tiling::tile_width"]
        [::std::mem::offset_of!(heif_image_tiling, tile_width) - 12usize];
    ["Offset of field: heif_image_tiling::tile_height"]
        [::std::mem::offset_of!(heif_image_tiling, tile_height) - 16usize];
    ["Offset of field: heif_image_tiling::image_width"]
        [::std::mem::offset_of!(heif_image_tiling, image_width) - 20usize];
    ["Offset of field: heif_image_tiling::image_height"]
        [::std::mem::offset_of!(heif_image_tiling, image_height) - 24usize];
    ["Offset of field: heif_image_tiling::top_offset"]
        [::std::mem::offset_of!(heif_image_tiling, top_offset) - 28usize];
    ["Offset of field: heif_image_tiling::left_offset"]
        [::std::mem::offset_of!(heif_image_tiling, left_offset) - 32usize];
    ["Offset of field: heif_image_tiling::number_of_extra_dimensions"]
        [::std::mem::offset_of!(heif_image_tiling, number_of_extra_dimensions) - 36usize];
    ["Offset of field: heif_image_tiling::extra_dimension_size"]
        [::std::mem::offset_of!(heif_image_tiling, extra_dimension_size) - 40usize];
};
extern "C" {
    pub fn heif_image_handle_get_image_tiling(
        handle: *const heif_image_handle,
        process_image_transformations: ::std::os::raw::c_int,
        out_tiling: *mut heif_image_tiling,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_handle_get_grid_image_tile_id(
        handle: *const heif_image_handle,
        process_image_transformations: ::std::os::raw::c_int,
        tile_x: u32,
        tile_y: u32,
        out_tile_item_id: *mut heif_item_id,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_handle_decode_image_tile(
        in_handle: *const heif_image_handle,
        out_img: *mut *mut heif_image,
        colorspace: heif_colorspace,
        chroma: heif_chroma,
        options: *const heif_decoding_options,
        tile_x: u32,
        tile_y: u32,
    ) -> heif_error;
}
pub type heif_entity_group_id = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_entity_group {
    pub entity_group_id: heif_entity_group_id,
    pub entity_group_type: u32,
    pub entities: *mut heif_item_id,
    pub num_entities: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_entity_group"][::std::mem::size_of::<heif_entity_group>() - 24usize];
    ["Alignment of heif_entity_group"][::std::mem::align_of::<heif_entity_group>() - 8usize];
    ["Offset of field: heif_entity_group::entity_group_id"]
        [::std::mem::offset_of!(heif_entity_group, entity_group_id) - 0usize];
    ["Offset of field: heif_entity_group::entity_group_type"]
        [::std::mem::offset_of!(heif_entity_group, entity_group_type) - 4usize];
    ["Offset of field: heif_entity_group::entities"]
        [::std::mem::offset_of!(heif_entity_group, entities) - 8usize];
    ["Offset of field: heif_entity_group::num_entities"]
        [::std::mem::offset_of!(heif_entity_group, num_entities) - 16usize];
};
extern "C" {
    pub fn heif_context_get_entity_groups(
        arg1: *const heif_context,
        type_filter: u32,
        item_filter: heif_item_id,
        out_num_groups: *mut ::std::os::raw::c_int,
    ) -> *mut heif_entity_group;
}
extern "C" {
    pub fn heif_entity_groups_release(
        arg1: *mut heif_entity_group,
        num_groups: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn heif_image_handle_has_depth_image(
        arg1: *const heif_image_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_number_of_depth_images(
        handle: *const heif_image_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_list_of_depth_image_IDs(
        handle: *const heif_image_handle,
        ids: *mut heif_item_id,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_depth_image_handle(
        handle: *const heif_image_handle,
        depth_image_id: heif_item_id,
        out_depth_handle: *mut *mut heif_image_handle,
    ) -> heif_error;
}
pub const heif_depth_representation_type_heif_depth_representation_type_uniform_inverse_Z:
    heif_depth_representation_type = 0;
pub const heif_depth_representation_type_heif_depth_representation_type_uniform_disparity:
    heif_depth_representation_type = 1;
pub const heif_depth_representation_type_heif_depth_representation_type_uniform_Z:
    heif_depth_representation_type = 2;
pub const heif_depth_representation_type_heif_depth_representation_type_nonuniform_disparity:
    heif_depth_representation_type = 3;
pub type heif_depth_representation_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_depth_representation_info {
    pub version: u8,
    pub has_z_near: u8,
    pub has_z_far: u8,
    pub has_d_min: u8,
    pub has_d_max: u8,
    pub z_near: f64,
    pub z_far: f64,
    pub d_min: f64,
    pub d_max: f64,
    pub depth_representation_type: heif_depth_representation_type,
    pub disparity_reference_view: u32,
    pub depth_nonlinear_representation_model_size: u32,
    pub depth_nonlinear_representation_model: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_depth_representation_info"]
        [::std::mem::size_of::<heif_depth_representation_info>() - 64usize];
    ["Alignment of heif_depth_representation_info"]
        [::std::mem::align_of::<heif_depth_representation_info>() - 8usize];
    ["Offset of field: heif_depth_representation_info::version"]
        [::std::mem::offset_of!(heif_depth_representation_info, version) - 0usize];
    ["Offset of field: heif_depth_representation_info::has_z_near"]
        [::std::mem::offset_of!(heif_depth_representation_info, has_z_near) - 1usize];
    ["Offset of field: heif_depth_representation_info::has_z_far"]
        [::std::mem::offset_of!(heif_depth_representation_info, has_z_far) - 2usize];
    ["Offset of field: heif_depth_representation_info::has_d_min"]
        [::std::mem::offset_of!(heif_depth_representation_info, has_d_min) - 3usize];
    ["Offset of field: heif_depth_representation_info::has_d_max"]
        [::std::mem::offset_of!(heif_depth_representation_info, has_d_max) - 4usize];
    ["Offset of field: heif_depth_representation_info::z_near"]
        [::std::mem::offset_of!(heif_depth_representation_info, z_near) - 8usize];
    ["Offset of field: heif_depth_representation_info::z_far"]
        [::std::mem::offset_of!(heif_depth_representation_info, z_far) - 16usize];
    ["Offset of field: heif_depth_representation_info::d_min"]
        [::std::mem::offset_of!(heif_depth_representation_info, d_min) - 24usize];
    ["Offset of field: heif_depth_representation_info::d_max"]
        [::std::mem::offset_of!(heif_depth_representation_info, d_max) - 32usize];
    ["Offset of field: heif_depth_representation_info::depth_representation_type"][::std::mem::offset_of!(
        heif_depth_representation_info,
        depth_representation_type
    ) - 40usize];
    ["Offset of field: heif_depth_representation_info::disparity_reference_view"][::std::mem::offset_of!(
        heif_depth_representation_info,
        disparity_reference_view
    ) - 44usize];
    ["Offset of field: heif_depth_representation_info::depth_nonlinear_representation_model_size"] [:: std :: mem :: offset_of ! (heif_depth_representation_info , depth_nonlinear_representation_model_size) - 48usize] ;
    ["Offset of field: heif_depth_representation_info::depth_nonlinear_representation_model"][::std::mem::offset_of!(
        heif_depth_representation_info,
        depth_nonlinear_representation_model
    )
        - 56usize];
};
extern "C" {
    pub fn heif_depth_representation_info_free(info: *const heif_depth_representation_info);
}
extern "C" {
    pub fn heif_image_handle_get_depth_image_representation_info(
        handle: *const heif_image_handle,
        depth_image_id: heif_item_id,
        out: *mut *const heif_depth_representation_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_number_of_thumbnails(
        handle: *const heif_image_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_list_of_thumbnail_IDs(
        handle: *const heif_image_handle,
        ids: *mut heif_item_id,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_thumbnail(
        main_image_handle: *const heif_image_handle,
        thumbnail_id: heif_item_id,
        out_thumbnail_handle: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_handle_get_number_of_auxiliary_images(
        handle: *const heif_image_handle,
        aux_filter: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_list_of_auxiliary_image_IDs(
        handle: *const heif_image_handle,
        aux_filter: ::std::os::raw::c_int,
        ids: *mut heif_item_id,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_auxiliary_type(
        handle: *const heif_image_handle,
        out_type: *mut *const ::std::os::raw::c_char,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_handle_release_auxiliary_type(
        handle: *const heif_image_handle,
        out_type: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn heif_image_handle_free_auxiliary_types(
        handle: *const heif_image_handle,
        out_type: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn heif_image_handle_get_auxiliary_image_handle(
        main_image_handle: *const heif_image_handle,
        auxiliary_id: heif_item_id,
        out_auxiliary_handle: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_handle_get_number_of_metadata_blocks(
        handle: *const heif_image_handle,
        type_filter: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_list_of_metadata_block_IDs(
        handle: *const heif_image_handle,
        type_filter: *const ::std::os::raw::c_char,
        ids: *mut heif_item_id,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_metadata_type(
        handle: *const heif_image_handle,
        metadata_id: heif_item_id,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heif_image_handle_get_metadata_content_type(
        handle: *const heif_image_handle,
        metadata_id: heif_item_id,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heif_image_handle_get_metadata_size(
        handle: *const heif_image_handle,
        metadata_id: heif_item_id,
    ) -> usize;
}
extern "C" {
    pub fn heif_image_handle_get_metadata(
        handle: *const heif_image_handle,
        metadata_id: heif_item_id,
        out_data: *mut ::std::os::raw::c_void,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_handle_get_metadata_item_uri_type(
        handle: *const heif_image_handle,
        metadata_id: heif_item_id,
    ) -> *const ::std::os::raw::c_char;
}
pub const heif_color_profile_type_heif_color_profile_type_not_present: heif_color_profile_type = 0;
pub const heif_color_profile_type_heif_color_profile_type_nclx: heif_color_profile_type =
    1852009592;
pub const heif_color_profile_type_heif_color_profile_type_rICC: heif_color_profile_type =
    1917403971;
pub const heif_color_profile_type_heif_color_profile_type_prof: heif_color_profile_type =
    1886547814;
pub type heif_color_profile_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn heif_image_handle_get_color_profile_type(
        handle: *const heif_image_handle,
    ) -> heif_color_profile_type;
}
extern "C" {
    pub fn heif_image_handle_get_raw_color_profile_size(handle: *const heif_image_handle) -> usize;
}
extern "C" {
    pub fn heif_image_handle_get_raw_color_profile(
        handle: *const heif_image_handle,
        out_data: *mut ::std::os::raw::c_void,
    ) -> heif_error;
}
pub const heif_color_primaries_heif_color_primaries_ITU_R_BT_709_5: heif_color_primaries = 1;
pub const heif_color_primaries_heif_color_primaries_unspecified: heif_color_primaries = 2;
pub const heif_color_primaries_heif_color_primaries_ITU_R_BT_470_6_System_M: heif_color_primaries =
    4;
pub const heif_color_primaries_heif_color_primaries_ITU_R_BT_470_6_System_B_G:
    heif_color_primaries = 5;
pub const heif_color_primaries_heif_color_primaries_ITU_R_BT_601_6: heif_color_primaries = 6;
pub const heif_color_primaries_heif_color_primaries_SMPTE_240M: heif_color_primaries = 7;
pub const heif_color_primaries_heif_color_primaries_generic_film: heif_color_primaries = 8;
pub const heif_color_primaries_heif_color_primaries_ITU_R_BT_2020_2_and_2100_0:
    heif_color_primaries = 9;
pub const heif_color_primaries_heif_color_primaries_SMPTE_ST_428_1: heif_color_primaries = 10;
pub const heif_color_primaries_heif_color_primaries_SMPTE_RP_431_2: heif_color_primaries = 11;
pub const heif_color_primaries_heif_color_primaries_SMPTE_EG_432_1: heif_color_primaries = 12;
pub const heif_color_primaries_heif_color_primaries_EBU_Tech_3213_E: heif_color_primaries = 22;
pub type heif_color_primaries = ::std::os::raw::c_uint;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_709_5:
    heif_transfer_characteristics = 1;
pub const heif_transfer_characteristics_heif_transfer_characteristic_unspecified:
    heif_transfer_characteristics = 2;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_470_6_System_M:
    heif_transfer_characteristics = 4;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_470_6_System_B_G:
    heif_transfer_characteristics = 5;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_601_6:
    heif_transfer_characteristics = 6;
pub const heif_transfer_characteristics_heif_transfer_characteristic_SMPTE_240M:
    heif_transfer_characteristics = 7;
pub const heif_transfer_characteristics_heif_transfer_characteristic_linear:
    heif_transfer_characteristics = 8;
pub const heif_transfer_characteristics_heif_transfer_characteristic_logarithmic_100:
    heif_transfer_characteristics = 9;
pub const heif_transfer_characteristics_heif_transfer_characteristic_logarithmic_100_sqrt10:
    heif_transfer_characteristics = 10;
pub const heif_transfer_characteristics_heif_transfer_characteristic_IEC_61966_2_4:
    heif_transfer_characteristics = 11;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_1361:
    heif_transfer_characteristics = 12;
pub const heif_transfer_characteristics_heif_transfer_characteristic_IEC_61966_2_1:
    heif_transfer_characteristics = 13;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_2020_2_10bit:
    heif_transfer_characteristics = 14;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_2020_2_12bit:
    heif_transfer_characteristics = 15;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_2100_0_PQ:
    heif_transfer_characteristics = 16;
pub const heif_transfer_characteristics_heif_transfer_characteristic_SMPTE_ST_428_1:
    heif_transfer_characteristics = 17;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_2100_0_HLG:
    heif_transfer_characteristics = 18;
pub type heif_transfer_characteristics = ::std::os::raw::c_uint;
pub const heif_matrix_coefficients_heif_matrix_coefficients_RGB_GBR: heif_matrix_coefficients = 0;
pub const heif_matrix_coefficients_heif_matrix_coefficients_ITU_R_BT_709_5:
    heif_matrix_coefficients = 1;
pub const heif_matrix_coefficients_heif_matrix_coefficients_unspecified: heif_matrix_coefficients =
    2;
pub const heif_matrix_coefficients_heif_matrix_coefficients_US_FCC_T47: heif_matrix_coefficients =
    4;
pub const heif_matrix_coefficients_heif_matrix_coefficients_ITU_R_BT_470_6_System_B_G:
    heif_matrix_coefficients = 5;
pub const heif_matrix_coefficients_heif_matrix_coefficients_ITU_R_BT_601_6:
    heif_matrix_coefficients = 6;
pub const heif_matrix_coefficients_heif_matrix_coefficients_SMPTE_240M: heif_matrix_coefficients =
    7;
pub const heif_matrix_coefficients_heif_matrix_coefficients_YCgCo: heif_matrix_coefficients = 8;
pub const heif_matrix_coefficients_heif_matrix_coefficients_ITU_R_BT_2020_2_non_constant_luminance : heif_matrix_coefficients = 9 ;
pub const heif_matrix_coefficients_heif_matrix_coefficients_ITU_R_BT_2020_2_constant_luminance:
    heif_matrix_coefficients = 10;
pub const heif_matrix_coefficients_heif_matrix_coefficients_SMPTE_ST_2085:
    heif_matrix_coefficients = 11;
pub const heif_matrix_coefficients_heif_matrix_coefficients_chromaticity_derived_non_constant_luminance : heif_matrix_coefficients = 12 ;
pub const heif_matrix_coefficients_heif_matrix_coefficients_chromaticity_derived_constant_luminance : heif_matrix_coefficients = 13 ;
pub const heif_matrix_coefficients_heif_matrix_coefficients_ICtCp: heif_matrix_coefficients = 14;
pub type heif_matrix_coefficients = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_color_profile_nclx {
    pub version: u8,
    pub color_primaries: heif_color_primaries,
    pub transfer_characteristics: heif_transfer_characteristics,
    pub matrix_coefficients: heif_matrix_coefficients,
    pub full_range_flag: u8,
    pub color_primary_red_x: f32,
    pub color_primary_red_y: f32,
    pub color_primary_green_x: f32,
    pub color_primary_green_y: f32,
    pub color_primary_blue_x: f32,
    pub color_primary_blue_y: f32,
    pub color_primary_white_x: f32,
    pub color_primary_white_y: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_color_profile_nclx"][::std::mem::size_of::<heif_color_profile_nclx>() - 52usize];
    ["Alignment of heif_color_profile_nclx"]
        [::std::mem::align_of::<heif_color_profile_nclx>() - 4usize];
    ["Offset of field: heif_color_profile_nclx::version"]
        [::std::mem::offset_of!(heif_color_profile_nclx, version) - 0usize];
    ["Offset of field: heif_color_profile_nclx::color_primaries"]
        [::std::mem::offset_of!(heif_color_profile_nclx, color_primaries) - 4usize];
    ["Offset of field: heif_color_profile_nclx::transfer_characteristics"]
        [::std::mem::offset_of!(heif_color_profile_nclx, transfer_characteristics) - 8usize];
    ["Offset of field: heif_color_profile_nclx::matrix_coefficients"]
        [::std::mem::offset_of!(heif_color_profile_nclx, matrix_coefficients) - 12usize];
    ["Offset of field: heif_color_profile_nclx::full_range_flag"]
        [::std::mem::offset_of!(heif_color_profile_nclx, full_range_flag) - 16usize];
    ["Offset of field: heif_color_profile_nclx::color_primary_red_x"]
        [::std::mem::offset_of!(heif_color_profile_nclx, color_primary_red_x) - 20usize];
    ["Offset of field: heif_color_profile_nclx::color_primary_red_y"]
        [::std::mem::offset_of!(heif_color_profile_nclx, color_primary_red_y) - 24usize];
    ["Offset of field: heif_color_profile_nclx::color_primary_green_x"]
        [::std::mem::offset_of!(heif_color_profile_nclx, color_primary_green_x) - 28usize];
    ["Offset of field: heif_color_profile_nclx::color_primary_green_y"]
        [::std::mem::offset_of!(heif_color_profile_nclx, color_primary_green_y) - 32usize];
    ["Offset of field: heif_color_profile_nclx::color_primary_blue_x"]
        [::std::mem::offset_of!(heif_color_profile_nclx, color_primary_blue_x) - 36usize];
    ["Offset of field: heif_color_profile_nclx::color_primary_blue_y"]
        [::std::mem::offset_of!(heif_color_profile_nclx, color_primary_blue_y) - 40usize];
    ["Offset of field: heif_color_profile_nclx::color_primary_white_x"]
        [::std::mem::offset_of!(heif_color_profile_nclx, color_primary_white_x) - 44usize];
    ["Offset of field: heif_color_profile_nclx::color_primary_white_y"]
        [::std::mem::offset_of!(heif_color_profile_nclx, color_primary_white_y) - 48usize];
};
extern "C" {
    pub fn heif_nclx_color_profile_set_color_primaries(
        nclx: *mut heif_color_profile_nclx,
        cp: u16,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_nclx_color_profile_set_transfer_characteristics(
        nclx: *mut heif_color_profile_nclx,
        transfer_characteristics: u16,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_nclx_color_profile_set_matrix_coefficients(
        nclx: *mut heif_color_profile_nclx,
        matrix_coefficients: u16,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_handle_get_nclx_color_profile(
        handle: *const heif_image_handle,
        out_data: *mut *mut heif_color_profile_nclx,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_nclx_color_profile_alloc() -> *mut heif_color_profile_nclx;
}
extern "C" {
    pub fn heif_nclx_color_profile_free(nclx_profile: *mut heif_color_profile_nclx);
}
extern "C" {
    pub fn heif_image_get_color_profile_type(image: *const heif_image) -> heif_color_profile_type;
}
extern "C" {
    pub fn heif_image_get_raw_color_profile_size(image: *const heif_image) -> usize;
}
extern "C" {
    pub fn heif_image_get_raw_color_profile(
        image: *const heif_image,
        out_data: *mut ::std::os::raw::c_void,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_get_nclx_color_profile(
        image: *const heif_image,
        out_data: *mut *mut heif_color_profile_nclx,
    ) -> heif_error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_camera_intrinsic_matrix {
    pub focal_length_x: f64,
    pub focal_length_y: f64,
    pub principal_point_x: f64,
    pub principal_point_y: f64,
    pub skew: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_camera_intrinsic_matrix"]
        [::std::mem::size_of::<heif_camera_intrinsic_matrix>() - 40usize];
    ["Alignment of heif_camera_intrinsic_matrix"]
        [::std::mem::align_of::<heif_camera_intrinsic_matrix>() - 8usize];
    ["Offset of field: heif_camera_intrinsic_matrix::focal_length_x"]
        [::std::mem::offset_of!(heif_camera_intrinsic_matrix, focal_length_x) - 0usize];
    ["Offset of field: heif_camera_intrinsic_matrix::focal_length_y"]
        [::std::mem::offset_of!(heif_camera_intrinsic_matrix, focal_length_y) - 8usize];
    ["Offset of field: heif_camera_intrinsic_matrix::principal_point_x"]
        [::std::mem::offset_of!(heif_camera_intrinsic_matrix, principal_point_x) - 16usize];
    ["Offset of field: heif_camera_intrinsic_matrix::principal_point_y"]
        [::std::mem::offset_of!(heif_camera_intrinsic_matrix, principal_point_y) - 24usize];
    ["Offset of field: heif_camera_intrinsic_matrix::skew"]
        [::std::mem::offset_of!(heif_camera_intrinsic_matrix, skew) - 32usize];
};
extern "C" {
    pub fn heif_image_handle_has_camera_intrinsic_matrix(
        handle: *const heif_image_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_camera_intrinsic_matrix(
        handle: *const heif_image_handle,
        out_matrix: *mut heif_camera_intrinsic_matrix,
    ) -> heif_error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_camera_extrinsic_matrix {
    _unused: [u8; 0],
}
extern "C" {
    pub fn heif_image_handle_has_camera_extrinsic_matrix(
        handle: *const heif_image_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_camera_extrinsic_matrix(
        handle: *const heif_image_handle,
        out_matrix: *mut *mut heif_camera_extrinsic_matrix,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_camera_extrinsic_matrix_release(arg1: *mut heif_camera_extrinsic_matrix);
}
extern "C" {
    pub fn heif_camera_extrinsic_matrix_get_rotation_matrix(
        arg1: *const heif_camera_extrinsic_matrix,
        out_matrix_row_major: *mut f64,
    ) -> heif_error;
}
pub const heif_progress_step_heif_progress_step_total: heif_progress_step = 0;
pub const heif_progress_step_heif_progress_step_load_tile: heif_progress_step = 1;
pub type heif_progress_step = ::std::os::raw::c_uint;
pub const heif_chroma_downsampling_algorithm_heif_chroma_downsampling_nearest_neighbor:
    heif_chroma_downsampling_algorithm = 1;
pub const heif_chroma_downsampling_algorithm_heif_chroma_downsampling_average:
    heif_chroma_downsampling_algorithm = 2;
pub const heif_chroma_downsampling_algorithm_heif_chroma_downsampling_sharp_yuv:
    heif_chroma_downsampling_algorithm = 3;
pub type heif_chroma_downsampling_algorithm = ::std::os::raw::c_uint;
pub const heif_chroma_upsampling_algorithm_heif_chroma_upsampling_nearest_neighbor:
    heif_chroma_upsampling_algorithm = 1;
pub const heif_chroma_upsampling_algorithm_heif_chroma_upsampling_bilinear:
    heif_chroma_upsampling_algorithm = 2;
pub type heif_chroma_upsampling_algorithm = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_color_conversion_options {
    pub version: u8,
    pub preferred_chroma_downsampling_algorithm: heif_chroma_downsampling_algorithm,
    pub preferred_chroma_upsampling_algorithm: heif_chroma_upsampling_algorithm,
    pub only_use_preferred_chroma_algorithm: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_color_conversion_options"]
        [::std::mem::size_of::<heif_color_conversion_options>() - 16usize];
    ["Alignment of heif_color_conversion_options"]
        [::std::mem::align_of::<heif_color_conversion_options>() - 4usize];
    ["Offset of field: heif_color_conversion_options::version"]
        [::std::mem::offset_of!(heif_color_conversion_options, version) - 0usize];
    ["Offset of field: heif_color_conversion_options::preferred_chroma_downsampling_algorithm"][::std::mem::offset_of!(
        heif_color_conversion_options,
        preferred_chroma_downsampling_algorithm
    )
        - 4usize];
    ["Offset of field: heif_color_conversion_options::preferred_chroma_upsampling_algorithm"][::std::mem::offset_of!(
        heif_color_conversion_options,
        preferred_chroma_upsampling_algorithm
    )
        - 8usize];
    ["Offset of field: heif_color_conversion_options::only_use_preferred_chroma_algorithm"][::std::mem::offset_of!(
        heif_color_conversion_options,
        only_use_preferred_chroma_algorithm
    )
        - 12usize];
};
extern "C" {
    pub fn heif_color_conversion_options_set_defaults(arg1: *mut heif_color_conversion_options);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_decoding_options {
    pub version: u8,
    pub ignore_transformations: u8,
    pub start_progress: ::std::option::Option<
        unsafe extern "C" fn(
            step: heif_progress_step,
            max_progress: ::std::os::raw::c_int,
            progress_user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub on_progress: ::std::option::Option<
        unsafe extern "C" fn(
            step: heif_progress_step,
            progress: ::std::os::raw::c_int,
            progress_user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub end_progress: ::std::option::Option<
        unsafe extern "C" fn(
            step: heif_progress_step,
            progress_user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub progress_user_data: *mut ::std::os::raw::c_void,
    pub convert_hdr_to_8bit: u8,
    pub strict_decoding: u8,
    pub decoder_id: *const ::std::os::raw::c_char,
    pub color_conversion_options: heif_color_conversion_options,
    pub cancel_decoding: ::std::option::Option<
        unsafe extern "C" fn(
            progress_user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_decoding_options"][::std::mem::size_of::<heif_decoding_options>() - 80usize];
    ["Alignment of heif_decoding_options"]
        [::std::mem::align_of::<heif_decoding_options>() - 8usize];
    ["Offset of field: heif_decoding_options::version"]
        [::std::mem::offset_of!(heif_decoding_options, version) - 0usize];
    ["Offset of field: heif_decoding_options::ignore_transformations"]
        [::std::mem::offset_of!(heif_decoding_options, ignore_transformations) - 1usize];
    ["Offset of field: heif_decoding_options::start_progress"]
        [::std::mem::offset_of!(heif_decoding_options, start_progress) - 8usize];
    ["Offset of field: heif_decoding_options::on_progress"]
        [::std::mem::offset_of!(heif_decoding_options, on_progress) - 16usize];
    ["Offset of field: heif_decoding_options::end_progress"]
        [::std::mem::offset_of!(heif_decoding_options, end_progress) - 24usize];
    ["Offset of field: heif_decoding_options::progress_user_data"]
        [::std::mem::offset_of!(heif_decoding_options, progress_user_data) - 32usize];
    ["Offset of field: heif_decoding_options::convert_hdr_to_8bit"]
        [::std::mem::offset_of!(heif_decoding_options, convert_hdr_to_8bit) - 40usize];
    ["Offset of field: heif_decoding_options::strict_decoding"]
        [::std::mem::offset_of!(heif_decoding_options, strict_decoding) - 41usize];
    ["Offset of field: heif_decoding_options::decoder_id"]
        [::std::mem::offset_of!(heif_decoding_options, decoder_id) - 48usize];
    ["Offset of field: heif_decoding_options::color_conversion_options"]
        [::std::mem::offset_of!(heif_decoding_options, color_conversion_options) - 56usize];
    ["Offset of field: heif_decoding_options::cancel_decoding"]
        [::std::mem::offset_of!(heif_decoding_options, cancel_decoding) - 72usize];
};
extern "C" {
    pub fn heif_decoding_options_alloc() -> *mut heif_decoding_options;
}
extern "C" {
    pub fn heif_decoding_options_free(arg1: *mut heif_decoding_options);
}
extern "C" {
    pub fn heif_decode_image(
        in_handle: *const heif_image_handle,
        out_img: *mut *mut heif_image,
        colorspace: heif_colorspace,
        chroma: heif_chroma,
        options: *const heif_decoding_options,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_get_colorspace(arg1: *const heif_image) -> heif_colorspace;
}
extern "C" {
    pub fn heif_image_get_chroma_format(arg1: *const heif_image) -> heif_chroma;
}
extern "C" {
    #[doc = " Get the width of a specified image channel.\n\n @param img the image to get the width for\n @param channel the channel to select\n @return the width of the channel in pixels, or -1 the channel does not exist in the image"]
    pub fn heif_image_get_width(
        img: *const heif_image,
        channel: heif_channel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the height of a specified image channel.\n\n @param img the image to get the height for\n @param channel the channel to select\n @return the height of the channel in pixels, or -1 the channel does not exist in the image"]
    pub fn heif_image_get_height(
        img: *const heif_image,
        channel: heif_channel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the width of the main channel.\n\n This is the Y channel in YCbCr or mono, or any in RGB.\n\n @param img the image to get the primary width for\n @return the width in pixels"]
    pub fn heif_image_get_primary_width(img: *const heif_image) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the height of the main channel.\n\n This is the Y channel in YCbCr or mono, or any in RGB.\n\n @param img the image to get the primary height for\n @return the height in pixels"]
    pub fn heif_image_get_primary_height(img: *const heif_image) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_crop(
        img: *mut heif_image,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_get_bits_per_pixel(
        arg1: *const heif_image,
        channel: heif_channel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_get_bits_per_pixel_range(
        arg1: *const heif_image,
        channel: heif_channel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_has_channel(
        arg1: *const heif_image,
        channel: heif_channel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_get_plane_readonly(
        arg1: *const heif_image,
        channel: heif_channel,
        out_stride: *mut ::std::os::raw::c_int,
    ) -> *const u8;
}
extern "C" {
    pub fn heif_image_get_plane(
        arg1: *mut heif_image,
        channel: heif_channel,
        out_stride: *mut ::std::os::raw::c_int,
    ) -> *mut u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_scaling_options {
    _unused: [u8; 0],
}
extern "C" {
    pub fn heif_image_scale_image(
        input: *const heif_image,
        output: *mut *mut heif_image,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        options: *const heif_scaling_options,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_extend_to_size_fill_with_zero(
        image: *mut heif_image,
        width: u32,
        height: u32,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_set_raw_color_profile(
        image: *mut heif_image,
        profile_type_fourcc_string: *const ::std::os::raw::c_char,
        profile_data: *const ::std::os::raw::c_void,
        profile_size: usize,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_set_nclx_color_profile(
        image: *mut heif_image,
        color_profile: *const heif_color_profile_nclx,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_get_decoding_warnings(
        image: *mut heif_image,
        first_warning_idx: ::std::os::raw::c_int,
        out_warnings: *mut heif_error,
        max_output_buffer_entries: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_add_decoding_warning(image: *mut heif_image, err: heif_error);
}
extern "C" {
    pub fn heif_image_release(arg1: *const heif_image);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_content_light_level {
    pub max_content_light_level: u16,
    pub max_pic_average_light_level: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_content_light_level"]
        [::std::mem::size_of::<heif_content_light_level>() - 4usize];
    ["Alignment of heif_content_light_level"]
        [::std::mem::align_of::<heif_content_light_level>() - 2usize];
    ["Offset of field: heif_content_light_level::max_content_light_level"]
        [::std::mem::offset_of!(heif_content_light_level, max_content_light_level) - 0usize];
    ["Offset of field: heif_content_light_level::max_pic_average_light_level"]
        [::std::mem::offset_of!(heif_content_light_level, max_pic_average_light_level) - 2usize];
};
extern "C" {
    pub fn heif_image_has_content_light_level(arg1: *const heif_image) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_get_content_light_level(
        arg1: *const heif_image,
        out: *mut heif_content_light_level,
    );
}
extern "C" {
    pub fn heif_image_handle_get_content_light_level(
        arg1: *const heif_image_handle,
        out: *mut heif_content_light_level,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_set_content_light_level(
        arg1: *const heif_image,
        in_: *const heif_content_light_level,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_mastering_display_colour_volume {
    pub display_primaries_x: [u16; 3usize],
    pub display_primaries_y: [u16; 3usize],
    pub white_point_x: u16,
    pub white_point_y: u16,
    pub max_display_mastering_luminance: u32,
    pub min_display_mastering_luminance: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_mastering_display_colour_volume"]
        [::std::mem::size_of::<heif_mastering_display_colour_volume>() - 24usize];
    ["Alignment of heif_mastering_display_colour_volume"]
        [::std::mem::align_of::<heif_mastering_display_colour_volume>() - 4usize];
    ["Offset of field: heif_mastering_display_colour_volume::display_primaries_x"][::std::mem::offset_of!(
        heif_mastering_display_colour_volume,
        display_primaries_x
    ) - 0usize];
    ["Offset of field: heif_mastering_display_colour_volume::display_primaries_y"][::std::mem::offset_of!(
        heif_mastering_display_colour_volume,
        display_primaries_y
    ) - 6usize];
    ["Offset of field: heif_mastering_display_colour_volume::white_point_x"]
        [::std::mem::offset_of!(heif_mastering_display_colour_volume, white_point_x) - 12usize];
    ["Offset of field: heif_mastering_display_colour_volume::white_point_y"]
        [::std::mem::offset_of!(heif_mastering_display_colour_volume, white_point_y) - 14usize];
    ["Offset of field: heif_mastering_display_colour_volume::max_display_mastering_luminance"][::std::mem::offset_of!(
        heif_mastering_display_colour_volume,
        max_display_mastering_luminance
    )
        - 16usize];
    ["Offset of field: heif_mastering_display_colour_volume::min_display_mastering_luminance"][::std::mem::offset_of!(
        heif_mastering_display_colour_volume,
        min_display_mastering_luminance
    )
        - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_decoded_mastering_display_colour_volume {
    pub display_primaries_x: [f32; 3usize],
    pub display_primaries_y: [f32; 3usize],
    pub white_point_x: f32,
    pub white_point_y: f32,
    pub max_display_mastering_luminance: f64,
    pub min_display_mastering_luminance: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_decoded_mastering_display_colour_volume"]
        [::std::mem::size_of::<heif_decoded_mastering_display_colour_volume>() - 48usize];
    ["Alignment of heif_decoded_mastering_display_colour_volume"]
        [::std::mem::align_of::<heif_decoded_mastering_display_colour_volume>() - 8usize];
    ["Offset of field: heif_decoded_mastering_display_colour_volume::display_primaries_x"][::std::mem::offset_of!(
        heif_decoded_mastering_display_colour_volume,
        display_primaries_x
    )
        - 0usize];
    ["Offset of field: heif_decoded_mastering_display_colour_volume::display_primaries_y"][::std::mem::offset_of!(
        heif_decoded_mastering_display_colour_volume,
        display_primaries_y
    )
        - 12usize];
    ["Offset of field: heif_decoded_mastering_display_colour_volume::white_point_x"][::std::mem::offset_of!(
        heif_decoded_mastering_display_colour_volume,
        white_point_x
    ) - 24usize];
    ["Offset of field: heif_decoded_mastering_display_colour_volume::white_point_y"][::std::mem::offset_of!(
        heif_decoded_mastering_display_colour_volume,
        white_point_y
    ) - 28usize];
    ["Offset of field: heif_decoded_mastering_display_colour_volume::max_display_mastering_luminance"] [:: std :: mem :: offset_of ! (heif_decoded_mastering_display_colour_volume , max_display_mastering_luminance) - 32usize] ;
    ["Offset of field: heif_decoded_mastering_display_colour_volume::min_display_mastering_luminance"] [:: std :: mem :: offset_of ! (heif_decoded_mastering_display_colour_volume , min_display_mastering_luminance) - 40usize] ;
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_ambient_viewing_environment {
    pub ambient_illumination: u32,
    pub ambient_light_x: u16,
    pub ambient_light_y: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_ambient_viewing_environment"]
        [::std::mem::size_of::<heif_ambient_viewing_environment>() - 8usize];
    ["Alignment of heif_ambient_viewing_environment"]
        [::std::mem::align_of::<heif_ambient_viewing_environment>() - 4usize];
    ["Offset of field: heif_ambient_viewing_environment::ambient_illumination"]
        [::std::mem::offset_of!(heif_ambient_viewing_environment, ambient_illumination) - 0usize];
    ["Offset of field: heif_ambient_viewing_environment::ambient_light_x"]
        [::std::mem::offset_of!(heif_ambient_viewing_environment, ambient_light_x) - 4usize];
    ["Offset of field: heif_ambient_viewing_environment::ambient_light_y"]
        [::std::mem::offset_of!(heif_ambient_viewing_environment, ambient_light_y) - 6usize];
};
extern "C" {
    pub fn heif_image_has_mastering_display_colour_volume(
        arg1: *const heif_image,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_get_mastering_display_colour_volume(
        arg1: *const heif_image,
        out: *mut heif_mastering_display_colour_volume,
    );
}
extern "C" {
    pub fn heif_image_handle_get_mastering_display_colour_volume(
        arg1: *const heif_image_handle,
        out: *mut heif_mastering_display_colour_volume,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_set_mastering_display_colour_volume(
        arg1: *const heif_image,
        in_: *const heif_mastering_display_colour_volume,
    );
}
extern "C" {
    pub fn heif_mastering_display_colour_volume_decode(
        in_: *const heif_mastering_display_colour_volume,
        out: *mut heif_decoded_mastering_display_colour_volume,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_get_pixel_aspect_ratio(
        arg1: *const heif_image,
        aspect_h: *mut u32,
        aspect_v: *mut u32,
    );
}
extern "C" {
    pub fn heif_image_handle_get_pixel_aspect_ratio(
        arg1: *const heif_image_handle,
        aspect_h: *mut u32,
        aspect_v: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_set_pixel_aspect_ratio(arg1: *mut heif_image, aspect_h: u32, aspect_v: u32);
}
extern "C" {
    pub fn heif_context_write_to_file(
        arg1: *mut heif_context,
        filename: *const ::std::os::raw::c_char,
    ) -> heif_error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_writer {
    pub writer_api_version: ::std::os::raw::c_int,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut heif_context,
            data: *const ::std::os::raw::c_void,
            size: usize,
            userdata: *mut ::std::os::raw::c_void,
        ) -> heif_error,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_writer"][::std::mem::size_of::<heif_writer>() - 16usize];
    ["Alignment of heif_writer"][::std::mem::align_of::<heif_writer>() - 8usize];
    ["Offset of field: heif_writer::writer_api_version"]
        [::std::mem::offset_of!(heif_writer, writer_api_version) - 0usize];
    ["Offset of field: heif_writer::write"][::std::mem::offset_of!(heif_writer, write) - 8usize];
};
extern "C" {
    pub fn heif_context_write(
        arg1: *mut heif_context,
        writer: *mut heif_writer,
        userdata: *mut ::std::os::raw::c_void,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_add_compatible_brand(ctx: *mut heif_context, compatible_brand: heif_brand2);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_encoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_encoder_descriptor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_encoder_parameter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_decoder_descriptor {
    _unused: [u8; 0],
}
extern "C" {
    pub fn heif_get_decoder_descriptors(
        format_filter: heif_compression_format,
        out_decoders: *mut *const heif_decoder_descriptor,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_decoder_descriptor_get_name(
        arg1: *const heif_decoder_descriptor,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heif_decoder_descriptor_get_id_name(
        arg1: *const heif_decoder_descriptor,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heif_context_get_encoder_descriptors(
        arg1: *mut heif_context,
        format_filter: heif_compression_format,
        name_filter: *const ::std::os::raw::c_char,
        out_encoders: *mut *const heif_encoder_descriptor,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_get_encoder_descriptors(
        format_filter: heif_compression_format,
        name_filter: *const ::std::os::raw::c_char,
        out_encoders: *mut *const heif_encoder_descriptor,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_encoder_descriptor_get_name(
        arg1: *const heif_encoder_descriptor,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heif_encoder_descriptor_get_id_name(
        arg1: *const heif_encoder_descriptor,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heif_encoder_descriptor_get_compression_format(
        arg1: *const heif_encoder_descriptor,
    ) -> heif_compression_format;
}
extern "C" {
    pub fn heif_encoder_descriptor_supports_lossy_compression(
        arg1: *const heif_encoder_descriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_encoder_descriptor_supports_lossless_compression(
        arg1: *const heif_encoder_descriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_context_get_encoder(
        context: *mut heif_context,
        arg1: *const heif_encoder_descriptor,
        out_encoder: *mut *mut heif_encoder,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_have_decoder_for_format(format: heif_compression_format) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_have_encoder_for_format(format: heif_compression_format) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_context_get_encoder_for_format(
        context: *mut heif_context,
        format: heif_compression_format,
        arg1: *mut *mut heif_encoder,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_release(arg1: *mut heif_encoder);
}
extern "C" {
    pub fn heif_encoder_get_name(arg1: *const heif_encoder) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heif_encoder_set_lossy_quality(
        arg1: *mut heif_encoder,
        quality: ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_set_lossless(
        arg1: *mut heif_encoder,
        enable: ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_set_logging_level(
        arg1: *mut heif_encoder,
        level: ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_list_parameters(
        arg1: *mut heif_encoder,
    ) -> *const *const heif_encoder_parameter;
}
extern "C" {
    pub fn heif_encoder_parameter_get_name(
        arg1: *const heif_encoder_parameter,
    ) -> *const ::std::os::raw::c_char;
}
pub const heif_encoder_parameter_type_heif_encoder_parameter_type_integer:
    heif_encoder_parameter_type = 1;
pub const heif_encoder_parameter_type_heif_encoder_parameter_type_boolean:
    heif_encoder_parameter_type = 2;
pub const heif_encoder_parameter_type_heif_encoder_parameter_type_string:
    heif_encoder_parameter_type = 3;
pub type heif_encoder_parameter_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn heif_encoder_parameter_get_type(
        arg1: *const heif_encoder_parameter,
    ) -> heif_encoder_parameter_type;
}
extern "C" {
    pub fn heif_encoder_parameter_get_valid_integer_range(
        arg1: *const heif_encoder_parameter,
        have_minimum_maximum: *mut ::std::os::raw::c_int,
        minimum: *mut ::std::os::raw::c_int,
        maximum: *mut ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_parameter_get_valid_integer_values(
        arg1: *const heif_encoder_parameter,
        have_minimum: *mut ::std::os::raw::c_int,
        have_maximum: *mut ::std::os::raw::c_int,
        minimum: *mut ::std::os::raw::c_int,
        maximum: *mut ::std::os::raw::c_int,
        num_valid_values: *mut ::std::os::raw::c_int,
        out_integer_array: *mut *const ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_parameter_get_valid_string_values(
        arg1: *const heif_encoder_parameter,
        out_stringarray: *mut *const *const ::std::os::raw::c_char,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_set_parameter_integer(
        arg1: *mut heif_encoder,
        parameter_name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_get_parameter_integer(
        arg1: *mut heif_encoder,
        parameter_name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_parameter_integer_valid_range(
        arg1: *mut heif_encoder,
        parameter_name: *const ::std::os::raw::c_char,
        have_minimum_maximum: *mut ::std::os::raw::c_int,
        minimum: *mut ::std::os::raw::c_int,
        maximum: *mut ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_set_parameter_boolean(
        arg1: *mut heif_encoder,
        parameter_name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_get_parameter_boolean(
        arg1: *mut heif_encoder,
        parameter_name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_set_parameter_string(
        arg1: *mut heif_encoder,
        parameter_name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_get_parameter_string(
        arg1: *mut heif_encoder,
        parameter_name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        value_size: ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_parameter_string_valid_values(
        arg1: *mut heif_encoder,
        parameter_name: *const ::std::os::raw::c_char,
        out_stringarray: *mut *const *const ::std::os::raw::c_char,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_parameter_integer_valid_values(
        arg1: *mut heif_encoder,
        parameter_name: *const ::std::os::raw::c_char,
        have_minimum: *mut ::std::os::raw::c_int,
        have_maximum: *mut ::std::os::raw::c_int,
        minimum: *mut ::std::os::raw::c_int,
        maximum: *mut ::std::os::raw::c_int,
        num_valid_values: *mut ::std::os::raw::c_int,
        out_integer_array: *mut *const ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_set_parameter(
        arg1: *mut heif_encoder,
        parameter_name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_get_parameter(
        arg1: *mut heif_encoder,
        parameter_name: *const ::std::os::raw::c_char,
        value_ptr: *mut ::std::os::raw::c_char,
        value_size: ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_has_default(
        arg1: *mut heif_encoder,
        parameter_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const heif_orientation_heif_orientation_normal: heif_orientation = 1;
pub const heif_orientation_heif_orientation_flip_horizontally: heif_orientation = 2;
pub const heif_orientation_heif_orientation_rotate_180: heif_orientation = 3;
pub const heif_orientation_heif_orientation_flip_vertically: heif_orientation = 4;
pub const heif_orientation_heif_orientation_rotate_90_cw_then_flip_horizontally: heif_orientation =
    5;
pub const heif_orientation_heif_orientation_rotate_90_cw: heif_orientation = 6;
pub const heif_orientation_heif_orientation_rotate_90_cw_then_flip_vertically: heif_orientation = 7;
pub const heif_orientation_heif_orientation_rotate_270_cw: heif_orientation = 8;
pub type heif_orientation = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_encoding_options {
    pub version: u8,
    pub save_alpha_channel: u8,
    pub macOS_compatibility_workaround: u8,
    pub save_two_colr_boxes_when_ICC_and_nclx_available: u8,
    pub output_nclx_profile: *mut heif_color_profile_nclx,
    pub macOS_compatibility_workaround_no_nclx_profile: u8,
    pub image_orientation: heif_orientation,
    pub color_conversion_options: heif_color_conversion_options,
    pub prefer_uncC_short_form: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heif_encoding_options"][::std::mem::size_of::<heif_encoding_options>() - 48usize];
    ["Alignment of heif_encoding_options"]
        [::std::mem::align_of::<heif_encoding_options>() - 8usize];
    ["Offset of field: heif_encoding_options::version"]
        [::std::mem::offset_of!(heif_encoding_options, version) - 0usize];
    ["Offset of field: heif_encoding_options::save_alpha_channel"]
        [::std::mem::offset_of!(heif_encoding_options, save_alpha_channel) - 1usize];
    ["Offset of field: heif_encoding_options::macOS_compatibility_workaround"]
        [::std::mem::offset_of!(heif_encoding_options, macOS_compatibility_workaround) - 2usize];
    ["Offset of field: heif_encoding_options::save_two_colr_boxes_when_ICC_and_nclx_available"][::std::mem::offset_of!(
        heif_encoding_options,
        save_two_colr_boxes_when_ICC_and_nclx_available
    )
        - 3usize];
    ["Offset of field: heif_encoding_options::output_nclx_profile"]
        [::std::mem::offset_of!(heif_encoding_options, output_nclx_profile) - 8usize];
    ["Offset of field: heif_encoding_options::macOS_compatibility_workaround_no_nclx_profile"][::std::mem::offset_of!(
        heif_encoding_options,
        macOS_compatibility_workaround_no_nclx_profile
    )
        - 16usize];
    ["Offset of field: heif_encoding_options::image_orientation"]
        [::std::mem::offset_of!(heif_encoding_options, image_orientation) - 20usize];
    ["Offset of field: heif_encoding_options::color_conversion_options"]
        [::std::mem::offset_of!(heif_encoding_options, color_conversion_options) - 24usize];
    ["Offset of field: heif_encoding_options::prefer_uncC_short_form"]
        [::std::mem::offset_of!(heif_encoding_options, prefer_uncC_short_form) - 40usize];
};
extern "C" {
    pub fn heif_encoding_options_alloc() -> *mut heif_encoding_options;
}
extern "C" {
    pub fn heif_encoding_options_free(arg1: *mut heif_encoding_options);
}
extern "C" {
    pub fn heif_context_encode_image(
        arg1: *mut heif_context,
        image: *const heif_image,
        encoder: *mut heif_encoder,
        options: *const heif_encoding_options,
        out_image_handle: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    #[doc = " @brief Encodes an array of images into a grid.\n\n @param ctx The file context\n @param tiles User allocated array of images that will form the grid.\n @param rows The number of rows in the grid.\n @param columns The number of columns in the grid.\n @param encoder Defines the encoder to use. See heif_context_get_encoder_for_format()\n @param input_options Optional, may be nullptr.\n @param out_image_handle Returns a handle to the grid. The caller is responsible for freeing it.\n @return Returns an error if ctx, tiles, or encoder is nullptr. If rows or columns is 0."]
    pub fn heif_context_encode_grid(
        ctx: *mut heif_context,
        tiles: *mut *mut heif_image,
        rows: u16,
        columns: u16,
        encoder: *mut heif_encoder,
        input_options: *const heif_encoding_options,
        out_image_handle: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_add_grid_image(
        ctx: *mut heif_context,
        image_width: u32,
        image_height: u32,
        tile_columns: u32,
        tile_rows: u32,
        encoding_options: *const heif_encoding_options,
        out_grid_image_handle: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_add_image_tile(
        ctx: *mut heif_context,
        tiled_image: *mut heif_image_handle,
        tile_x: u32,
        tile_y: u32,
        image: *const heif_image,
        encoder: *mut heif_encoder,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_add_overlay_image(
        ctx: *mut heif_context,
        image_width: u32,
        image_height: u32,
        nImages: u16,
        image_ids: *const heif_item_id,
        offsets: *mut i32,
        background_rgba: *const u16,
        out_iovl_image_handle: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_set_primary_image(
        arg1: *mut heif_context,
        image_handle: *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_encode_thumbnail(
        arg1: *mut heif_context,
        image: *const heif_image,
        master_image_handle: *const heif_image_handle,
        encoder: *mut heif_encoder,
        options: *const heif_encoding_options,
        bbox_size: ::std::os::raw::c_int,
        out_thumb_image_handle: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_assign_thumbnail(
        arg1: *mut heif_context,
        master_image: *const heif_image_handle,
        thumbnail_image: *const heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_add_exif_metadata(
        arg1: *mut heif_context,
        image_handle: *const heif_image_handle,
        data: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_add_XMP_metadata(
        arg1: *mut heif_context,
        image_handle: *const heif_image_handle,
        data: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_add_XMP_metadata2(
        arg1: *mut heif_context,
        image_handle: *const heif_image_handle,
        data: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        compression: heif_metadata_compression,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_add_generic_metadata(
        ctx: *mut heif_context,
        image_handle: *const heif_image_handle,
        data: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        item_type: *const ::std::os::raw::c_char,
        content_type: *const ::std::os::raw::c_char,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_add_generic_uri_metadata(
        ctx: *mut heif_context,
        image_handle: *const heif_image_handle,
        data: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        item_uri_type: *const ::std::os::raw::c_char,
        out_item_id: *mut heif_item_id,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Create a new image of the specified resolution and colorspace.\n\n <p>This does not allocate memory for the image data. Use {@link heif_image_add_plane} to\n add the corresponding planes to match the specified {@code colorspace} and {@code chroma}.\n\n @param width the width of the image in pixels\n @param height the height of the image in pixels\n @param colorspace the colorspace of the image\n @param chroma the chroma of the image\n @param out_image pointer to pointer of the resulting image\n @return whether the creation succeeded or there was an error"]
    pub fn heif_image_create(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        colorspace: heif_colorspace,
        chroma: heif_chroma,
        out_image: *mut *mut heif_image,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Add an image plane to the image.\n\n <p>The image plane needs to match the colorspace and chroma of the image. Note\n that this does not need to be a single \"planar\" format - interleaved pixel channels\n can also be used if the chroma is interleaved.\n\n <p>The indicated bit_depth corresponds to the bit depth per channel. For example,\n with an interleaved format like RRGGBB where each color is represented by 10 bits,\n the {@code bit_depth} would be {@code 10} rather than {@code 30}.\n\n <p>For backward compatibility, one can also specify 24bits for RGB and 32bits for RGBA,\n instead of the preferred 8 bits. However, this use is deprecated.\n\n @param image the parent image to add the channel plane to\n @param channel the channel of the plane to add\n @param width the width of the plane\n @param height the height of the plane\n @param bit_depth the bit depth per color channel\n @return whether the addition succeeded or there was an error\n\n @note The width and height are usually the same as the parent image, but can be\n less for subsampling.\n\n @note The specified width can differ from the row stride of the resulting image plane.\n Always use the result of {@link heif_image_get_plane} or {@link heif_image_get_plane_readonly}\n to determine row stride."]
    pub fn heif_image_add_plane(
        image: *mut heif_image,
        channel: heif_channel,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bit_depth: ::std::os::raw::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_set_premultiplied_alpha(
        image: *mut heif_image,
        is_premultiplied_alpha: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn heif_image_is_premultiplied_alpha(image: *mut heif_image) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_image_extend_padding_to_size(
        image: *mut heif_image,
        min_physical_width: ::std::os::raw::c_int,
        min_physical_height: ::std::os::raw::c_int,
    ) -> heif_error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_decoder_plugin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_encoder_plugin {
    _unused: [u8; 0],
}
extern "C" {
    pub fn heif_register_decoder(
        heif: *mut heif_context,
        arg1: *const heif_decoder_plugin,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_register_decoder_plugin(arg1: *const heif_decoder_plugin) -> heif_error;
}
extern "C" {
    pub fn heif_register_encoder_plugin(arg1: *const heif_encoder_plugin) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_descriptor_supportes_lossy_compression(
        arg1: *const heif_encoder_descriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heif_encoder_descriptor_supportes_lossless_compression(
        arg1: *const heif_encoder_descriptor,
    ) -> ::std::os::raw::c_int;
}
